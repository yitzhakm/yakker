(** This module deals with generating the top-level bindings of the
generated module. It includes the code to handle boilerplate and code
that deals with how to bind the transducer representation that is
generated by the [Fsm] module. *)

open Yak
open Gul

type backend = Cmdline.backend =
  | Fun_BE   (** Functional backend (parser combinators).*)
  | Wadler_BE   (** Haskell functional backend (parser combinators).*)
  | Peg_BE of bool (** PEG backend. argument indicates whether
                       to use more liberal (PADS-style) star. *)
  | Trans_BE (** Transducer backend. *)

let mk_trans_bp = Printf.sprintf "
module M = Yak.Pami.Wfe.Make(
    struct
      module Parse_engine = %s
      module Term_language = %s
      let start_symbol_name = %S

      let sv0 = sv0
      module Semval =
      struct
        type t = sv
        let cmp = sv_compare
        include %s
      end

      let program = program
      let get_symb_action = get_symb_action
      let get_symb_start = get_symb_start
      let min_symbol = %d
      let num_symbols = num_symbols
      let opt_mode = %s
      let default_call = %s
      let default_ret = %s
    end)
let parse = M.gen_parse %s
"

let trans_bp gr ppf =
  let parse_engine =
    match !Compileopt.gen_nullpreds, !Compileopt.earley_ds with
      | true, Compileopt.Sparse_eds -> "Yak.Engine"
      | false, Compileopt.Sparse_eds -> "Yak.Engine_nr"
      | true, Compileopt.Hierhash_eds -> "Yak.Engine_hh"
      | false, Compileopt.Hierhash_eds -> Util.todo "Hierarchical engine data structures cannot (yet) be used without nullpreds."
      | true, Compileopt.Hiermap_eds -> "Yak.Engine_hm"
      | false, Compileopt.Hiermap_eds -> Util.todo "Hierarchical engine data structures cannot (yet) be used without nullpreds."
      | true, Compileopt.Flat_eds -> "Yak.Engine_fl"
      | false, Compileopt.Flat_eds -> "Yak.Engine_nrfl" in
  let term_lang = if gr.has_single_lexer then Variables.tk_mod else "Parse_engine.Scannerless_term_lang" in
  let inspector_mod =
    if gr.grammar_late_relevant && not !Compileopt.unit_history then
      let prefix = if gr.grammar_early_relevant then "E_" else "" in
      Printf.sprintf "Yak.Pami.Wfe.%sHistory_inspector(Yk_History)" prefix
    else
      "Parse_engine.Dummy_inspector" in
  let opt_mode =
    if !Compileopt.gen_optimize_pam
    then "Yak.PamJIT.Full_opt"
    else "Yak.PamJIT.No_opt" in
  mk_trans_bp
    parse_engine
    term_lang
    gr.start_symbol
    inspector_mod
    Fsm.min_symbol
    opt_mode
    Fsm.default_call_tx
    Fsm.default_binder_tx
    ppf

let add_boilerplate backend out gr =
  if backend = Wadler_BE then ()
  else
  (* The [unit_history] flag overrides the standard history relevance. *)
  let post_parse_function =
    if gr.grammar_late_relevant && not !Compileopt.unit_history then
      let name = Variables.bnf2ocaml gr.start_symbol in
      if gr.grammar_early_relevant then
        Printf.sprintf "(fun ykinput (_,h) -> _replay_%s ykinput h)" name
      else Printf.sprintf "_replay_%s" name
    else
      "(fun ykinput x -> ())" in
  let boilerplate_vary =
    match backend with
      | Trans_BE -> trans_bp gr post_parse_function
      | Fun_BE | Peg_BE _ ->
          "\nlet parse = Yak.Pami.mk_parse_fun __parse " ^ post_parse_function
      | Wadler_BE -> "" in
  let boilerplate_shared =
    "let parse_file = Yak.Pami.Simple.parse_file parse\n\
     let parse_string = Yak.Pami.Simple.parse_string parse\n;;\n"in
  add_to_epilogue gr (boilerplate_vary ^ boilerplate_shared)


let gil_transducer =
  if !Compileopt.use_fsm then
    (fun is_sv_known -> Fsm.try_fsm (Fsm.fsm_transducer is_sv_known))
  else
    (fun is_sv_known -> Fsm.try_fst (Fsm.fsm_transducer is_sv_known))

let print_prologue ch gr =
  List.iter begin function
    | Ocaml x ->
        Printf.fprintf ch "%s" x
    | _ -> failwith "Non-ocaml blob in prologue"
  end
    (List.rev gr.prologue)

let print_epilogue ch gr =
  List.iter begin function
    | Ocaml x ->
        Printf.fprintf ch "%s" x
    | _ -> failwith "Non-ocaml blob in epilogue"
  end
    gr.epilogue

let do_compile is_sv_known backend out gr =
    let print_prologue () = print_prologue out gr in
    let print_epilogue () = print_epilogue out gr in

    (match backend with
      | Fun_BE ->
          print_prologue ();
          Gil_gen.pr_gil_definitions2 out gr.start_symbol gr.tokmap gr.gildefs
      | Wadler_BE ->
          gr.prologue <- [];
          gr.epilogue <- [];
          Gil_gen.Wadler.pr_definitions out gr.start_symbol gr.gildefs
      | Peg_BE liberal ->
          print_prologue ();
          Gil_gen.Peg.pr_definitions out liberal gr.start_symbol gr.gildefs
      | Trans_BE ->
          print_prologue ();
          gil_transducer is_sv_known out gr);

    add_boilerplate backend out gr;

    if is_sv_known then
      begin
        print_epilogue ()
      end

let do_compile_for_arrow backend out gr =
    let print_prologue () = print_prologue out gr in
    (match backend with
    | Fun_BE ->
        print_prologue ();
        Gil_gen.pr_gil_definitions2 out gr.start_symbol gr.tokmap gr.gildefs
    | Wadler_BE ->
        gr.prologue <- [];
        gr.epilogue <- [];
        Gil_gen.Wadler.pr_definitions out gr.start_symbol gr.gildefs
    | Peg_BE liberal ->
        print_prologue ();
        Gil_gen.Peg.pr_definitions out liberal gr.start_symbol gr.gildefs
    | Trans_BE ->
        print_prologue ();
        if !Compileopt.wrap_codegen_in_module then begin
          Printf.fprintf out "module Internal : sig
    val __default_call : 'a -> 'b -> sv
    val __default_ret : 'a -> 'b -> 'c -> 'b
    val num_symbols : int
    val symbol_table : int -> string
    val get_symb_action : string -> int
    val get_symb_start : int -> int
    val program : (int * sv Yak.Pam_internal.instruction list) list
  end = struct\n"
        end;

        gil_transducer true out gr;

        if !Compileopt.wrap_codegen_in_module then begin
          Printf.fprintf out "end\nopen Internal;;\n\n";
        end;
    );

    add_boilerplate backend out gr;
    print_epilogue out gr
