(** This module deals with generating the top-level bindings of the
generated module. It includes the code to handle boilerplate and code
that deals with how to bind the transducer representation that is
generated by the [Fsm] module. *)

(* TODO:
    - get rid of Wadler_BE and generally clean up the code that handles backends. i think it should be object-style. perhaps,
      inline add_boilerplate code.
     - get rid of all the infrastructure for doing 2-pass compile.
    x refactor so that [do_compile] would
    get a buffer from Fsm with the transducer, rather than just invoking an imperative
    function printing.
    x pass the transducer buffer to [add_boilerplate] to give it precise control over
   where in the output stream the transducer binding appears.  For [mk_trans_bp_v2] this control is critical
   because we want to print it inside module [A] so that it won't be externally visible. External visibility
   can lead to errors with ungeneralizable type variables. *)

open Yak
open Gul

type backend = Cmdline.backend =
  | Fun_BE   (** Functional backend (parser combinators).*)
  | Wadler_BE   (** Haskell functional backend (parser combinators).*)
  | Peg_BE of bool (** PEG backend. argument indicates whether
                       to use more liberal (PADS-style) star. *)
  | Trans_BE (** Transducer backend. *)

(** This function is an experimental code generator whose goal is to
    avoid the need to run Yakker in two passes. It uses OCaml 3.12's
    new support for explicit type parameters on functions to get an
    explicit name for the various types which the first-pass is now
    being used to extract. *)
let mk_trans_bp_v2
    tx_buf
    parse_engine
    term_lang
    start_symbol
    inspector_mod
    min_symbol
    opt_mode
    default_call
    default_binder
    ppf =
  Printf.sprintf "
let f = fun (type ev)
  (sv0 : ev svt) (sv_compare : ev svt -> ev svt -> int)
  (program : (int * ev svt Yak.Pam_internal.instruction list) list)
  (dc : ev svt Yak.Pam_internal.action2)
  (dr : ev svt Yak.Pam_internal.binder2) g ->

let module A =
    struct
      module Parse_engine = %s
      module Term_language = %s
      let start_symbol_name = %S

      let sv0 = sv0
      module Semval =
      struct
        type t = ev svt
        let cmp = sv_compare
        include %s
      end

      let program = program
      let get_symb_action = get_symb_action
      let get_symb_start = get_symb_start
      let min_symbol = %d
      let num_symbols = num_symbols
      let opt_mode = %s
      let default_call = dc
      let default_ret = dr
    end in
let module M = Yak.Pami.Wfe.Make(A) in
M.gen_parse g

let parse =
  let program = %a in
  f sv0 sv_compare program %s %s %s
"
    parse_engine
    term_lang
    start_symbol
    inspector_mod
    min_symbol
    opt_mode
    (fun () b -> Buffer.contents b) tx_buf
    default_call
    default_binder
    ppf

let mk_trans_bp_v1 = Printf.sprintf "
let program = %a
module M = Yak.Pami.Wfe.Make(
    struct
      module Parse_engine = %s
      module Term_language = %s
      let start_symbol_name = %S

      let sv0 = sv0
      module Semval =
      struct
        type t = sv
        let cmp = sv_compare
        include %s
      end

      let program = program
      let get_symb_action = get_symb_action
      let get_symb_start = get_symb_start
      let min_symbol = %d
      let num_symbols = num_symbols
      let opt_mode = %s
      let default_call = %s
      let default_ret = %s
    end)
let parse = M.gen_parse %s
" (fun () b -> Buffer.contents b)

let trans_bp gr tx_buf ppf mk_trans_bp =
  let parse_engine =
    match !Compileopt.gen_nullpreds, !Compileopt.earley_ds with
      | true, Compileopt.Sparse_eds -> "Yak.Engine"
      | false, Compileopt.Sparse_eds -> "Yak.Engine_nr"
      | true, Compileopt.Hierhash_eds -> "Yak.Engine_hh"
      | false, Compileopt.Hierhash_eds -> Util.todo "Hierarchical engine data structures cannot (yet) be used without nullpreds."
      | true, Compileopt.Hiermap_eds -> "Yak.Engine_hm"
      | false, Compileopt.Hiermap_eds -> Util.todo "Hierarchical engine data structures cannot (yet) be used without nullpreds."
      | true, Compileopt.Flat_eds -> "Yak.Engine_fl"
      | false, Compileopt.Flat_eds -> "Yak.Engine_nrfl" in
  let term_lang = if gr.has_single_lexer then Variables.tk_mod else "Parse_engine.Scannerless_term_lang" in
  let inspector_mod =
    if gr.grammar_late_relevant && not !Compileopt.unit_history then
      let prefix = if gr.grammar_early_relevant then "E_" else "" in
      Printf.sprintf "Yak.Pami.Wfe.%sHistory_inspector(Yk_History)" prefix
    else
      "Parse_engine.Dummy_inspector" in
  let opt_mode =
    if !Compileopt.gen_optimize_pam
    then "Yak.PamJIT.Full_opt"
    else "Yak.PamJIT.No_opt" in
  mk_trans_bp
    tx_buf
    parse_engine
    term_lang
    gr.start_symbol
    inspector_mod
    Fsm.min_symbol
    opt_mode
    Fsm.default_call_tx
    Fsm.default_binder_tx
    ppf

let add_boilerplate backend gr tx_buf =
  if backend = Wadler_BE then () else

  let post_parse_function =
    (* The [unit_history] flag overrides the standard history relevance. *)
    if gr.grammar_late_relevant && not !Compileopt.unit_history then
      let name = Variables.bnf2ocaml gr.start_symbol in
      if gr.grammar_early_relevant then
        Printf.sprintf "(fun ykinput (_,h) -> _replay_%s ykinput h)" name
      else Printf.sprintf "_replay_%s" name
    else
      "(fun ykinput x -> ())" in
  let boilerplate_vary =
    match backend with
      | Trans_BE ->
          trans_bp gr tx_buf post_parse_function
            (if !Compileopt.infer_types_in_two_passes
             then mk_trans_bp_v1
             else mk_trans_bp_v2)
      | Fun_BE | Peg_BE _ ->
          "\nlet parse = Yak.Pami.mk_parse_fun __parse " ^ post_parse_function
      | Wadler_BE -> "" in

  let boilerplate_shared =
    "let parse_file = Yak.Pami.Simple.parse_file parse\n\
     let parse_string = Yak.Pami.Simple.parse_string parse\n;;\n" in

  add_many_to_epilogue gr [ boilerplate_vary   ;
                            boilerplate_shared ]


let print_gil_transducer is_sv_known =
  if !Compileopt.use_fsm then
    Fsm.try_fsm (Fsm.fsm_transducer is_sv_known)
  else
    Fsm.try_fst (Fsm.fsm_transducer is_sv_known)

let print_prologue ch gr =
  List.iter begin function
    | Ocaml x ->
        Printf.fprintf ch "%s" x
    | _ -> failwith "Non-ocaml blob in prologue"
  end
    (List.rev gr.prologue)

let print_epilogue ch gr =
  List.iter begin function
    | Ocaml x ->
        Printf.fprintf ch "%s" x
    | _ -> failwith "Non-ocaml blob in epilogue"
  end
    gr.epilogue

let do_compile is_sv_known backend out gr =
    let print_prologue () = print_prologue out gr in
    let print_epilogue () = print_epilogue out gr in

    let transducer_buffer = match backend with
      | Fun_BE ->
          print_prologue ();
          Gil_gen.pr_gil_definitions2 out gr.start_symbol gr.tokmap gr.gildefs;
          Buffer.create 0
      | Wadler_BE ->
          gr.prologue <- [];
          gr.epilogue <- [];
          Gil_gen.Wadler.pr_definitions out gr.start_symbol gr.gildefs;
          Buffer.create 0
      | Peg_BE liberal ->
          print_prologue ();
          Gil_gen.Peg.pr_definitions out liberal gr.start_symbol gr.gildefs;
          Buffer.create 0
      | Trans_BE ->
          print_prologue ();
          print_gil_transducer is_sv_known out gr in

    add_boilerplate backend gr transducer_buffer;

    if is_sv_known then
      begin
        print_epilogue ()
      end

let do_compile_for_arrow backend out gr =
  let maybe_wrap_in_module f out =
    if not !Compileopt.wrap_codegen_in_module then f out
    else begin
      Printf.fprintf out "module Internal : sig
    val __default_call : 'a -> 'b -> sv
    val __default_ret : 'a -> 'b -> 'c -> 'b
    val num_symbols : int
    val symbol_table : int -> string
    val get_symb_action : string -> int
    val get_symb_start : int -> int
  end = struct\n";
      let b = f out in
      Printf.fprintf out "\nend\nopen Internal;;\n\n";
      b
      end in
  let print_prologue () = print_prologue out gr in
  let transducer_buffer = begin match backend with
    | Fun_BE ->
        print_prologue ();
        Gil_gen.pr_gil_definitions2 out gr.start_symbol gr.tokmap gr.gildefs;
        Buffer.create 0
    | Wadler_BE ->
        gr.prologue <- [];
        gr.epilogue <- [];
        Gil_gen.Wadler.pr_definitions out gr.start_symbol gr.gildefs;
        Buffer.create 0
    | Peg_BE liberal ->
        print_prologue ();
        Gil_gen.Peg.pr_definitions out liberal gr.start_symbol gr.gildefs;
        Buffer.create 0
    | Trans_BE ->
        print_prologue ();
        maybe_wrap_in_module (fun out -> print_gil_transducer true out gr) out
  end in
  add_boilerplate backend gr transducer_buffer;
  print_epilogue out gr
